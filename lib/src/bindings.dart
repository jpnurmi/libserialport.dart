/// AUTO GENERATED FILE, DO NOT EDIT.
///
/// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// libserialport: cross-platform library for accessing serial ports
class LibSerialPort {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  LibSerialPort(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  /// Obtain a pointer to a new sp_port structure representing the named port.
  ///
  /// The user should allocate a variable of type "struct sp_port *" and pass a
  /// pointer to this to receive the result.
  ///
  /// The result should be freed after use by calling sp_free_port().
  ///
  /// @param[in] portname The OS-specific name of a serial port. Must not be NULL.
  /// @param[out] port_ptr If any error is returned, the variable pointed to by
  /// port_ptr will be set to NULL. Otherwise, it will be set
  /// to point to the newly allocated port. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_port_by_name(
    ffi.Pointer<ffi.Int8> portname,
    ffi.Pointer<ffi.Pointer<sp_port>> port_ptr,
  ) {
    _sp_get_port_by_name ??= _dylib.lookupFunction<_c_sp_get_port_by_name,
        _dart_sp_get_port_by_name>('sp_get_port_by_name');
    return _sp_get_port_by_name(
      portname,
      port_ptr,
    );
  }

  _dart_sp_get_port_by_name _sp_get_port_by_name;

  /// Free a port structure obtained from sp_get_port_by_name() or sp_copy_port().
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @since 0.1.0
  void sp_free_port(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_free_port ??= _dylib
        .lookupFunction<_c_sp_free_port, _dart_sp_free_port>('sp_free_port');
    return _sp_free_port(
      port,
    );
  }

  _dart_sp_free_port _sp_free_port;

  /// List the serial ports available on the system.
  ///
  /// The result obtained is an array of pointers to sp_port structures,
  /// terminated by a NULL. The user should allocate a variable of type
  /// "struct sp_port **" and pass a pointer to this to receive the result.
  ///
  /// The result should be freed after use by calling sp_free_port_list().
  /// If a port from the list is to be used after freeing the list, it must be
  /// copied first using sp_copy_port().
  ///
  /// @param[out] list_ptr If any error is returned, the variable pointed to by
  /// list_ptr will be set to NULL. Otherwise, it will be set
  /// to point to the newly allocated array. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_list_ports(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<sp_port>>> list_ptr,
  ) {
    _sp_list_ports ??= _dylib
        .lookupFunction<_c_sp_list_ports, _dart_sp_list_ports>('sp_list_ports');
    return _sp_list_ports(
      list_ptr,
    );
  }

  _dart_sp_list_ports _sp_list_ports;

  /// Make a new copy of an sp_port structure.
  ///
  /// The user should allocate a variable of type "struct sp_port *" and pass a
  /// pointer to this to receive the result.
  ///
  /// The copy should be freed after use by calling sp_free_port().
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] copy_ptr If any error is returned, the variable pointed to by
  /// copy_ptr will be set to NULL. Otherwise, it will be set
  /// to point to the newly allocated copy. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_copy_port(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Pointer<sp_port>> copy_ptr,
  ) {
    _sp_copy_port ??= _dylib
        .lookupFunction<_c_sp_copy_port, _dart_sp_copy_port>('sp_copy_port');
    return _sp_copy_port(
      port,
      copy_ptr,
    );
  }

  _dart_sp_copy_port _sp_copy_port;

  /// Free a port list obtained from sp_list_ports().
  ///
  /// This will also free all the sp_port structures referred to from the list;
  /// any that are to be retained must be copied first using sp_copy_port().
  ///
  /// @param[in] ports Pointer to a list of port structures. Must not be NULL.
  ///
  /// @since 0.1.0
  void sp_free_port_list(
    ffi.Pointer<ffi.Pointer<sp_port>> ports,
  ) {
    _sp_free_port_list ??=
        _dylib.lookupFunction<_c_sp_free_port_list, _dart_sp_free_port_list>(
            'sp_free_port_list');
    return _sp_free_port_list(
      ports,
    );
  }

  _dart_sp_free_port_list _sp_free_port_list;

  /// Open the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] flags Flags to use when opening the serial port.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_open(
    ffi.Pointer<sp_port> port,
    int flags,
  ) {
    _sp_open ??= _dylib.lookupFunction<_c_sp_open, _dart_sp_open>('sp_open');
    return _sp_open(
      port,
      flags,
    );
  }

  _dart_sp_open _sp_open;

  /// Close the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_close(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_close ??=
        _dylib.lookupFunction<_c_sp_close, _dart_sp_close>('sp_close');
    return _sp_close(
      port,
    );
  }

  _dart_sp_close _sp_close;

  /// Get the name of a port.
  ///
  /// The name returned is whatever is normally used to refer to a port on the
  /// current operating system; e.g. for Windows it will usually be a "COMn"
  /// device name, and for Unix it will be a device path beginning with "/dev/".
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return The port name, or NULL if an invalid port is passed. The name
  /// string is part of the port structure and may not be used after
  /// the port structure has been freed.
  ///
  /// @since 0.1.0
  ffi.Pointer<ffi.Int8> sp_get_port_name(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_get_port_name ??=
        _dylib.lookupFunction<_c_sp_get_port_name, _dart_sp_get_port_name>(
            'sp_get_port_name');
    return _sp_get_port_name(
      port,
    );
  }

  _dart_sp_get_port_name _sp_get_port_name;

  /// Get a description for a port, to present to end user.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return The port description, or NULL if an invalid port is passed.
  /// The description string is part of the port structure and may not
  /// be used after the port structure has been freed.
  ///
  /// @since 0.1.1
  ffi.Pointer<ffi.Int8> sp_get_port_description(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_get_port_description ??= _dylib.lookupFunction<
        _c_sp_get_port_description,
        _dart_sp_get_port_description>('sp_get_port_description');
    return _sp_get_port_description(
      port,
    );
  }

  _dart_sp_get_port_description _sp_get_port_description;

  /// Get the transport type used by a port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return The port transport type.
  ///
  /// @since 0.1.1
  int sp_get_port_transport(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_get_port_transport ??= _dylib.lookupFunction<_c_sp_get_port_transport,
        _dart_sp_get_port_transport>('sp_get_port_transport');
    return _sp_get_port_transport(
      port,
    );
  }

  _dart_sp_get_port_transport _sp_get_port_transport;

  /// Get the USB bus number and address on bus of a USB serial adapter port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] usb_bus Pointer to a variable to store the USB bus.
  /// Can be NULL (in that case it will be ignored).
  /// @param[out] usb_address Pointer to a variable to store the USB address.
  /// Can be NULL (in that case it will be ignored).
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.1
  int sp_get_port_usb_bus_address(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Int32> usb_bus,
    ffi.Pointer<ffi.Int32> usb_address,
  ) {
    _sp_get_port_usb_bus_address ??= _dylib.lookupFunction<
        _c_sp_get_port_usb_bus_address,
        _dart_sp_get_port_usb_bus_address>('sp_get_port_usb_bus_address');
    return _sp_get_port_usb_bus_address(
      port,
      usb_bus,
      usb_address,
    );
  }

  _dart_sp_get_port_usb_bus_address _sp_get_port_usb_bus_address;

  /// Get the USB Vendor ID and Product ID of a USB serial adapter port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] usb_vid Pointer to a variable to store the USB VID.
  /// Can be NULL (in that case it will be ignored).
  /// @param[out] usb_pid Pointer to a variable to store the USB PID.
  /// Can be NULL (in that case it will be ignored).
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.1
  int sp_get_port_usb_vid_pid(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Int32> usb_vid,
    ffi.Pointer<ffi.Int32> usb_pid,
  ) {
    _sp_get_port_usb_vid_pid ??= _dylib.lookupFunction<
        _c_sp_get_port_usb_vid_pid,
        _dart_sp_get_port_usb_vid_pid>('sp_get_port_usb_vid_pid');
    return _sp_get_port_usb_vid_pid(
      port,
      usb_vid,
      usb_pid,
    );
  }

  _dart_sp_get_port_usb_vid_pid _sp_get_port_usb_vid_pid;

  /// Get the USB manufacturer string of a USB serial adapter port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return The port manufacturer string, or NULL if an invalid port is passed.
  /// The manufacturer string is part of the port structure and may not
  /// be used after the port structure has been freed.
  ///
  /// @since 0.1.1
  ffi.Pointer<ffi.Int8> sp_get_port_usb_manufacturer(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_get_port_usb_manufacturer ??= _dylib.lookupFunction<
        _c_sp_get_port_usb_manufacturer,
        _dart_sp_get_port_usb_manufacturer>('sp_get_port_usb_manufacturer');
    return _sp_get_port_usb_manufacturer(
      port,
    );
  }

  _dart_sp_get_port_usb_manufacturer _sp_get_port_usb_manufacturer;

  /// Get the USB product string of a USB serial adapter port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return The port product string, or NULL if an invalid port is passed.
  /// The product string is part of the port structure and may not be
  /// used after the port structure has been freed.
  ///
  /// @since 0.1.1
  ffi.Pointer<ffi.Int8> sp_get_port_usb_product(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_get_port_usb_product ??= _dylib.lookupFunction<
        _c_sp_get_port_usb_product,
        _dart_sp_get_port_usb_product>('sp_get_port_usb_product');
    return _sp_get_port_usb_product(
      port,
    );
  }

  _dart_sp_get_port_usb_product _sp_get_port_usb_product;

  /// Get the USB serial number string of a USB serial adapter port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return The port serial number, or NULL if an invalid port is passed.
  /// The serial number string is part of the port structure and may
  /// not be used after the port structure has been freed.
  ///
  /// @since 0.1.1
  ffi.Pointer<ffi.Int8> sp_get_port_usb_serial(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_get_port_usb_serial ??= _dylib.lookupFunction<_c_sp_get_port_usb_serial,
        _dart_sp_get_port_usb_serial>('sp_get_port_usb_serial');
    return _sp_get_port_usb_serial(
      port,
    );
  }

  _dart_sp_get_port_usb_serial _sp_get_port_usb_serial;

  /// Get the MAC address of a Bluetooth serial adapter port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return The port MAC address, or NULL if an invalid port is passed.
  /// The MAC address string is part of the port structure and may not
  /// be used after the port structure has been freed.
  ///
  /// @since 0.1.1
  ffi.Pointer<ffi.Int8> sp_get_port_bluetooth_address(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_get_port_bluetooth_address ??= _dylib.lookupFunction<
        _c_sp_get_port_bluetooth_address,
        _dart_sp_get_port_bluetooth_address>('sp_get_port_bluetooth_address');
    return _sp_get_port_bluetooth_address(
      port,
    );
  }

  _dart_sp_get_port_bluetooth_address _sp_get_port_bluetooth_address;

  /// Get the operating system handle for a port.
  ///
  /// The type of the handle depends on the operating system. On Unix based
  /// systems, the handle is a file descriptor of type "int". On Windows, the
  /// handle is of type "HANDLE". The user should allocate a variable of the
  /// appropriate type and pass a pointer to this to receive the result.
  ///
  /// To obtain a valid handle, the port must first be opened by calling
  /// sp_open() using the same port structure.
  ///
  /// After the port is closed or the port structure freed, the handle may
  /// no longer be valid.
  ///
  /// @warning This feature is provided so that programs may make use of
  /// OS-specific functionality where desired. Doing so obviously
  /// comes at a cost in portability. It also cannot be guaranteed
  /// that direct usage of the OS handle will not conflict with the
  /// library's own usage of the port. Be careful.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] result_ptr If any error is returned, the variable pointed to by
  /// result_ptr will have unknown contents and should not
  /// be used. Otherwise, it will be set to point to the
  /// OS handle. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_port_handle(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Void> result_ptr,
  ) {
    _sp_get_port_handle ??=
        _dylib.lookupFunction<_c_sp_get_port_handle, _dart_sp_get_port_handle>(
            'sp_get_port_handle');
    return _sp_get_port_handle(
      port,
      result_ptr,
    );
  }

  _dart_sp_get_port_handle _sp_get_port_handle;

  /// Allocate a port configuration structure.
  ///
  /// The user should allocate a variable of type "struct sp_port_config *" and
  /// pass a pointer to this to receive the result. The variable will be updated
  /// to point to the new configuration structure. The structure is opaque and
  /// must be accessed via the functions provided.
  ///
  /// All parameters in the structure will be initialised to special values which
  /// are ignored by sp_set_config().
  ///
  /// The structure should be freed after use by calling sp_free_config().
  ///
  /// @param[out] config_ptr If any error is returned, the variable pointed to by
  /// config_ptr will be set to NULL. Otherwise, it will
  /// be set to point to the allocated config structure.
  /// Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_new_config(
    ffi.Pointer<ffi.Pointer<sp_port_config>> config_ptr,
  ) {
    _sp_new_config ??= _dylib
        .lookupFunction<_c_sp_new_config, _dart_sp_new_config>('sp_new_config');
    return _sp_new_config(
      config_ptr,
    );
  }

  _dart_sp_new_config _sp_new_config;

  /// Free a port configuration structure.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  ///
  /// @since 0.1.0
  void sp_free_config(
    ffi.Pointer<sp_port_config> config,
  ) {
    _sp_free_config ??=
        _dylib.lookupFunction<_c_sp_free_config, _dart_sp_free_config>(
            'sp_free_config');
    return _sp_free_config(
      config,
    );
  }

  _dart_sp_free_config _sp_free_config;

  /// Get the current configuration of the specified serial port.
  ///
  /// The user should allocate a configuration structure using sp_new_config()
  /// and pass this as the config parameter. The configuration structure will
  /// be updated with the port configuration.
  ///
  /// Any parameters that are configured with settings not recognised or
  /// supported by libserialport, will be set to special values that are
  /// ignored by sp_set_config().
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] config Pointer to a configuration structure that will hold
  /// the result. Upon errors the contents of the config
  /// struct will not be changed. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<sp_port_config> config,
  ) {
    _sp_get_config ??= _dylib
        .lookupFunction<_c_sp_get_config, _dart_sp_get_config>('sp_get_config');
    return _sp_get_config(
      port,
      config,
    );
  }

  _dart_sp_get_config _sp_get_config;

  /// Set the configuration for the specified serial port.
  ///
  /// For each parameter in the configuration, there is a special value (usually
  /// -1, but see the documentation for each field). These values will be ignored
  /// and the corresponding setting left unchanged on the port.
  ///
  /// Upon errors, the configuration of the serial port is unknown since
  /// partial/incomplete config updates may have happened.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<sp_port_config> config,
  ) {
    _sp_set_config ??= _dylib
        .lookupFunction<_c_sp_set_config, _dart_sp_set_config>('sp_set_config');
    return _sp_set_config(
      port,
      config,
    );
  }

  _dart_sp_set_config _sp_set_config;

  /// Set the baud rate for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] baudrate Baud rate in bits per second.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_baudrate(
    ffi.Pointer<sp_port> port,
    int baudrate,
  ) {
    _sp_set_baudrate ??=
        _dylib.lookupFunction<_c_sp_set_baudrate, _dart_sp_set_baudrate>(
            'sp_set_baudrate');
    return _sp_set_baudrate(
      port,
      baudrate,
    );
  }

  _dart_sp_set_baudrate _sp_set_baudrate;

  /// Get the baud rate from a port configuration.
  ///
  /// The user should allocate a variable of type int and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] baudrate_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_baudrate(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> baudrate_ptr,
  ) {
    _sp_get_config_baudrate ??= _dylib.lookupFunction<_c_sp_get_config_baudrate,
        _dart_sp_get_config_baudrate>('sp_get_config_baudrate');
    return _sp_get_config_baudrate(
      config,
      baudrate_ptr,
    );
  }

  _dart_sp_get_config_baudrate _sp_get_config_baudrate;

  /// Set the baud rate in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] baudrate Baud rate in bits per second, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_baudrate(
    ffi.Pointer<sp_port_config> config,
    int baudrate,
  ) {
    _sp_set_config_baudrate ??= _dylib.lookupFunction<_c_sp_set_config_baudrate,
        _dart_sp_set_config_baudrate>('sp_set_config_baudrate');
    return _sp_set_config_baudrate(
      config,
      baudrate,
    );
  }

  _dart_sp_set_config_baudrate _sp_set_config_baudrate;

  /// Set the data bits for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] bits Number of data bits.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_bits(
    ffi.Pointer<sp_port> port,
    int bits,
  ) {
    _sp_set_bits ??=
        _dylib.lookupFunction<_c_sp_set_bits, _dart_sp_set_bits>('sp_set_bits');
    return _sp_set_bits(
      port,
      bits,
    );
  }

  _dart_sp_set_bits _sp_set_bits;

  /// Get the data bits from a port configuration.
  ///
  /// The user should allocate a variable of type int and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] bits_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_bits(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> bits_ptr,
  ) {
    _sp_get_config_bits ??=
        _dylib.lookupFunction<_c_sp_get_config_bits, _dart_sp_get_config_bits>(
            'sp_get_config_bits');
    return _sp_get_config_bits(
      config,
      bits_ptr,
    );
  }

  _dart_sp_get_config_bits _sp_get_config_bits;

  /// Set the data bits in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] bits Number of data bits, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_bits(
    ffi.Pointer<sp_port_config> config,
    int bits,
  ) {
    _sp_set_config_bits ??=
        _dylib.lookupFunction<_c_sp_set_config_bits, _dart_sp_set_config_bits>(
            'sp_set_config_bits');
    return _sp_set_config_bits(
      config,
      bits,
    );
  }

  _dart_sp_set_config_bits _sp_set_config_bits;

  /// Set the parity setting for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] parity Parity setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_parity(
    ffi.Pointer<sp_port> port,
    int parity,
  ) {
    _sp_set_parity ??= _dylib
        .lookupFunction<_c_sp_set_parity, _dart_sp_set_parity>('sp_set_parity');
    return _sp_set_parity(
      port,
      parity,
    );
  }

  _dart_sp_set_parity _sp_set_parity;

  /// Get the parity setting from a port configuration.
  ///
  /// The user should allocate a variable of type enum sp_parity and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] parity_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_parity(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> parity_ptr,
  ) {
    _sp_get_config_parity ??= _dylib.lookupFunction<_c_sp_get_config_parity,
        _dart_sp_get_config_parity>('sp_get_config_parity');
    return _sp_get_config_parity(
      config,
      parity_ptr,
    );
  }

  _dart_sp_get_config_parity _sp_get_config_parity;

  /// Set the parity setting in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] parity Parity setting, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_parity(
    ffi.Pointer<sp_port_config> config,
    int parity,
  ) {
    _sp_set_config_parity ??= _dylib.lookupFunction<_c_sp_set_config_parity,
        _dart_sp_set_config_parity>('sp_set_config_parity');
    return _sp_set_config_parity(
      config,
      parity,
    );
  }

  _dart_sp_set_config_parity _sp_set_config_parity;

  /// Set the stop bits for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] stopbits Number of stop bits.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_stopbits(
    ffi.Pointer<sp_port> port,
    int stopbits,
  ) {
    _sp_set_stopbits ??=
        _dylib.lookupFunction<_c_sp_set_stopbits, _dart_sp_set_stopbits>(
            'sp_set_stopbits');
    return _sp_set_stopbits(
      port,
      stopbits,
    );
  }

  _dart_sp_set_stopbits _sp_set_stopbits;

  /// Get the stop bits from a port configuration.
  ///
  /// The user should allocate a variable of type int and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] stopbits_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_stopbits(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> stopbits_ptr,
  ) {
    _sp_get_config_stopbits ??= _dylib.lookupFunction<_c_sp_get_config_stopbits,
        _dart_sp_get_config_stopbits>('sp_get_config_stopbits');
    return _sp_get_config_stopbits(
      config,
      stopbits_ptr,
    );
  }

  _dart_sp_get_config_stopbits _sp_get_config_stopbits;

  /// Set the stop bits in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] stopbits Number of stop bits, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_stopbits(
    ffi.Pointer<sp_port_config> config,
    int stopbits,
  ) {
    _sp_set_config_stopbits ??= _dylib.lookupFunction<_c_sp_set_config_stopbits,
        _dart_sp_set_config_stopbits>('sp_set_config_stopbits');
    return _sp_set_config_stopbits(
      config,
      stopbits,
    );
  }

  _dart_sp_set_config_stopbits _sp_set_config_stopbits;

  /// Set the RTS pin behaviour for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] rts RTS pin mode.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_rts(
    ffi.Pointer<sp_port> port,
    int rts,
  ) {
    _sp_set_rts ??=
        _dylib.lookupFunction<_c_sp_set_rts, _dart_sp_set_rts>('sp_set_rts');
    return _sp_set_rts(
      port,
      rts,
    );
  }

  _dart_sp_set_rts _sp_set_rts;

  /// Get the RTS pin behaviour from a port configuration.
  ///
  /// The user should allocate a variable of type enum sp_rts and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] rts_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_rts(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> rts_ptr,
  ) {
    _sp_get_config_rts ??=
        _dylib.lookupFunction<_c_sp_get_config_rts, _dart_sp_get_config_rts>(
            'sp_get_config_rts');
    return _sp_get_config_rts(
      config,
      rts_ptr,
    );
  }

  _dart_sp_get_config_rts _sp_get_config_rts;

  /// Set the RTS pin behaviour in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] rts RTS pin mode, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_rts(
    ffi.Pointer<sp_port_config> config,
    int rts,
  ) {
    _sp_set_config_rts ??=
        _dylib.lookupFunction<_c_sp_set_config_rts, _dart_sp_set_config_rts>(
            'sp_set_config_rts');
    return _sp_set_config_rts(
      config,
      rts,
    );
  }

  _dart_sp_set_config_rts _sp_set_config_rts;

  /// Set the CTS pin behaviour for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] cts CTS pin mode.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_cts(
    ffi.Pointer<sp_port> port,
    int cts,
  ) {
    _sp_set_cts ??=
        _dylib.lookupFunction<_c_sp_set_cts, _dart_sp_set_cts>('sp_set_cts');
    return _sp_set_cts(
      port,
      cts,
    );
  }

  _dart_sp_set_cts _sp_set_cts;

  /// Get the CTS pin behaviour from a port configuration.
  ///
  /// The user should allocate a variable of type enum sp_cts and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] cts_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_cts(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> cts_ptr,
  ) {
    _sp_get_config_cts ??=
        _dylib.lookupFunction<_c_sp_get_config_cts, _dart_sp_get_config_cts>(
            'sp_get_config_cts');
    return _sp_get_config_cts(
      config,
      cts_ptr,
    );
  }

  _dart_sp_get_config_cts _sp_get_config_cts;

  /// Set the CTS pin behaviour in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] cts CTS pin mode, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_cts(
    ffi.Pointer<sp_port_config> config,
    int cts,
  ) {
    _sp_set_config_cts ??=
        _dylib.lookupFunction<_c_sp_set_config_cts, _dart_sp_set_config_cts>(
            'sp_set_config_cts');
    return _sp_set_config_cts(
      config,
      cts,
    );
  }

  _dart_sp_set_config_cts _sp_set_config_cts;

  /// Set the DTR pin behaviour for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] dtr DTR pin mode.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_dtr(
    ffi.Pointer<sp_port> port,
    int dtr,
  ) {
    _sp_set_dtr ??=
        _dylib.lookupFunction<_c_sp_set_dtr, _dart_sp_set_dtr>('sp_set_dtr');
    return _sp_set_dtr(
      port,
      dtr,
    );
  }

  _dart_sp_set_dtr _sp_set_dtr;

  /// Get the DTR pin behaviour from a port configuration.
  ///
  /// The user should allocate a variable of type enum sp_dtr and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] dtr_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_dtr(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> dtr_ptr,
  ) {
    _sp_get_config_dtr ??=
        _dylib.lookupFunction<_c_sp_get_config_dtr, _dart_sp_get_config_dtr>(
            'sp_get_config_dtr');
    return _sp_get_config_dtr(
      config,
      dtr_ptr,
    );
  }

  _dart_sp_get_config_dtr _sp_get_config_dtr;

  /// Set the DTR pin behaviour in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] dtr DTR pin mode, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_dtr(
    ffi.Pointer<sp_port_config> config,
    int dtr,
  ) {
    _sp_set_config_dtr ??=
        _dylib.lookupFunction<_c_sp_set_config_dtr, _dart_sp_set_config_dtr>(
            'sp_set_config_dtr');
    return _sp_set_config_dtr(
      config,
      dtr,
    );
  }

  _dart_sp_set_config_dtr _sp_set_config_dtr;

  /// Set the DSR pin behaviour for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] dsr DSR pin mode.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_dsr(
    ffi.Pointer<sp_port> port,
    int dsr,
  ) {
    _sp_set_dsr ??=
        _dylib.lookupFunction<_c_sp_set_dsr, _dart_sp_set_dsr>('sp_set_dsr');
    return _sp_set_dsr(
      port,
      dsr,
    );
  }

  _dart_sp_set_dsr _sp_set_dsr;

  /// Get the DSR pin behaviour from a port configuration.
  ///
  /// The user should allocate a variable of type enum sp_dsr and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] dsr_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_dsr(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> dsr_ptr,
  ) {
    _sp_get_config_dsr ??=
        _dylib.lookupFunction<_c_sp_get_config_dsr, _dart_sp_get_config_dsr>(
            'sp_get_config_dsr');
    return _sp_get_config_dsr(
      config,
      dsr_ptr,
    );
  }

  _dart_sp_get_config_dsr _sp_get_config_dsr;

  /// Set the DSR pin behaviour in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] dsr DSR pin mode, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_dsr(
    ffi.Pointer<sp_port_config> config,
    int dsr,
  ) {
    _sp_set_config_dsr ??=
        _dylib.lookupFunction<_c_sp_set_config_dsr, _dart_sp_set_config_dsr>(
            'sp_set_config_dsr');
    return _sp_set_config_dsr(
      config,
      dsr,
    );
  }

  _dart_sp_set_config_dsr _sp_set_config_dsr;

  /// Set the XON/XOFF configuration for the specified serial port.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] xon_xoff XON/XOFF mode.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_xon_xoff(
    ffi.Pointer<sp_port> port,
    int xon_xoff,
  ) {
    _sp_set_xon_xoff ??=
        _dylib.lookupFunction<_c_sp_set_xon_xoff, _dart_sp_set_xon_xoff>(
            'sp_set_xon_xoff');
    return _sp_set_xon_xoff(
      port,
      xon_xoff,
    );
  }

  _dart_sp_set_xon_xoff _sp_set_xon_xoff;

  /// Get the XON/XOFF configuration from a port configuration.
  ///
  /// The user should allocate a variable of type enum sp_xonxoff and
  /// pass a pointer to this to receive the result.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[out] xon_xoff_ptr Pointer to a variable to store the result. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_config_xon_xoff(
    ffi.Pointer<sp_port_config> config,
    ffi.Pointer<ffi.Int32> xon_xoff_ptr,
  ) {
    _sp_get_config_xon_xoff ??= _dylib.lookupFunction<_c_sp_get_config_xon_xoff,
        _dart_sp_get_config_xon_xoff>('sp_get_config_xon_xoff');
    return _sp_get_config_xon_xoff(
      config,
      xon_xoff_ptr,
    );
  }

  _dart_sp_get_config_xon_xoff _sp_get_config_xon_xoff;

  /// Set the XON/XOFF configuration in a port configuration.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] xon_xoff XON/XOFF mode, or -1 to retain the current setting.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_xon_xoff(
    ffi.Pointer<sp_port_config> config,
    int xon_xoff,
  ) {
    _sp_set_config_xon_xoff ??= _dylib.lookupFunction<_c_sp_set_config_xon_xoff,
        _dart_sp_set_config_xon_xoff>('sp_set_config_xon_xoff');
    return _sp_set_config_xon_xoff(
      config,
      xon_xoff,
    );
  }

  _dart_sp_set_config_xon_xoff _sp_set_config_xon_xoff;

  /// Set the flow control type in a port configuration.
  ///
  /// This function is a wrapper that sets the RTS, CTS, DTR, DSR and
  /// XON/XOFF settings as necessary for the specified flow control
  /// type. For more fine-grained control of these settings, use their
  /// individual configuration functions.
  ///
  /// @param[in] config Pointer to a configuration structure. Must not be NULL.
  /// @param[in] flowcontrol Flow control setting to use.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_config_flowcontrol(
    ffi.Pointer<sp_port_config> config,
    int flowcontrol,
  ) {
    _sp_set_config_flowcontrol ??= _dylib.lookupFunction<
        _c_sp_set_config_flowcontrol,
        _dart_sp_set_config_flowcontrol>('sp_set_config_flowcontrol');
    return _sp_set_config_flowcontrol(
      config,
      flowcontrol,
    );
  }

  _dart_sp_set_config_flowcontrol _sp_set_config_flowcontrol;

  /// Set the flow control type for the specified serial port.
  ///
  /// This function is a wrapper that sets the RTS, CTS, DTR, DSR and
  /// XON/XOFF settings as necessary for the specified flow control
  /// type. For more fine-grained control of these settings, use their
  /// individual configuration functions.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] flowcontrol Flow control setting to use.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_set_flowcontrol(
    ffi.Pointer<sp_port> port,
    int flowcontrol,
  ) {
    _sp_set_flowcontrol ??=
        _dylib.lookupFunction<_c_sp_set_flowcontrol, _dart_sp_set_flowcontrol>(
            'sp_set_flowcontrol');
    return _sp_set_flowcontrol(
      port,
      flowcontrol,
    );
  }

  _dart_sp_set_flowcontrol _sp_set_flowcontrol;

  /// Read bytes from the specified serial port, blocking until complete.
  ///
  /// @warning If your program runs on Unix, defines its own signal handlers, and
  /// needs to abort blocking reads when these are called, then you
  /// should not use this function. It repeats system calls that return
  /// with EINTR. To be able to abort a read from a signal handler, you
  /// should implement your own blocking read using sp_nonblocking_read()
  /// together with a blocking method that makes sense for your program.
  /// E.g. you can obtain the file descriptor for an open port using
  /// sp_get_port_handle() and use this to call select() or pselect(),
  /// with appropriate arrangements to return if a signal is received.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] buf Buffer in which to store the bytes read. Must not be NULL.
  /// @param[in] count Requested number of bytes to read.
  /// @param[in] timeout_ms Timeout in milliseconds, or zero to wait indefinitely.
  ///
  /// @return The number of bytes read on success, or a negative error code. If
  /// the number of bytes returned is less than that requested, the
  /// timeout was reached before the requested number of bytes was
  /// available. If timeout is zero, the function will always return
  /// either the requested number of bytes or a negative error code.
  ///
  /// @since 0.1.0
  int sp_blocking_read(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Void> buf,
    int count,
    int timeout_ms,
  ) {
    _sp_blocking_read ??=
        _dylib.lookupFunction<_c_sp_blocking_read, _dart_sp_blocking_read>(
            'sp_blocking_read');
    return _sp_blocking_read(
      port,
      buf,
      count,
      timeout_ms,
    );
  }

  _dart_sp_blocking_read _sp_blocking_read;

  /// Read bytes from the specified serial port, returning as soon as any data is
  /// available.
  ///
  /// @warning If your program runs on Unix, defines its own signal handlers, and
  /// needs to abort blocking reads when these are called, then you
  /// should not use this function. It repeats system calls that return
  /// with EINTR. To be able to abort a read from a signal handler, you
  /// should implement your own blocking read using sp_nonblocking_read()
  /// together with a blocking method that makes sense for your program.
  /// E.g. you can obtain the file descriptor for an open port using
  /// sp_get_port_handle() and use this to call select() or pselect(),
  /// with appropriate arrangements to return if a signal is received.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] buf Buffer in which to store the bytes read. Must not be NULL.
  /// @param[in] count Maximum number of bytes to read. Must not be zero.
  /// @param[in] timeout_ms Timeout in milliseconds, or zero to wait indefinitely.
  ///
  /// @return The number of bytes read on success, or a negative error code. If
  /// the result is zero, the timeout was reached before any bytes were
  /// available. If timeout_ms is zero, the function will always return
  /// either at least one byte, or a negative error code.
  ///
  /// @since 0.1.1
  int sp_blocking_read_next(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Void> buf,
    int count,
    int timeout_ms,
  ) {
    _sp_blocking_read_next ??= _dylib.lookupFunction<_c_sp_blocking_read_next,
        _dart_sp_blocking_read_next>('sp_blocking_read_next');
    return _sp_blocking_read_next(
      port,
      buf,
      count,
      timeout_ms,
    );
  }

  _dart_sp_blocking_read_next _sp_blocking_read_next;

  /// Read bytes from the specified serial port, without blocking.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] buf Buffer in which to store the bytes read. Must not be NULL.
  /// @param[in] count Maximum number of bytes to read.
  ///
  /// @return The number of bytes read on success, or a negative error code. The
  /// number of bytes returned may be any number from zero to the maximum
  /// that was requested.
  ///
  /// @since 0.1.0
  int sp_nonblocking_read(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Void> buf,
    int count,
  ) {
    _sp_nonblocking_read ??= _dylib.lookupFunction<_c_sp_nonblocking_read,
        _dart_sp_nonblocking_read>('sp_nonblocking_read');
    return _sp_nonblocking_read(
      port,
      buf,
      count,
    );
  }

  _dart_sp_nonblocking_read _sp_nonblocking_read;

  /// Write bytes to the specified serial port, blocking until complete.
  ///
  /// Note that this function only ensures that the accepted bytes have been
  /// written to the OS; they may be held in driver or hardware buffers and not
  /// yet physically transmitted. To check whether all written bytes have actually
  /// been transmitted, use the sp_output_waiting() function. To wait until all
  /// written bytes have actually been transmitted, use the sp_drain() function.
  ///
  /// @warning If your program runs on Unix, defines its own signal handlers, and
  /// needs to abort blocking writes when these are called, then you
  /// should not use this function. It repeats system calls that return
  /// with EINTR. To be able to abort a write from a signal handler, you
  /// should implement your own blocking write using sp_nonblocking_write()
  /// together with a blocking method that makes sense for your program.
  /// E.g. you can obtain the file descriptor for an open port using
  /// sp_get_port_handle() and use this to call select() or pselect(),
  /// with appropriate arrangements to return if a signal is received.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] buf Buffer containing the bytes to write. Must not be NULL.
  /// @param[in] count Requested number of bytes to write.
  /// @param[in] timeout_ms Timeout in milliseconds, or zero to wait indefinitely.
  ///
  /// @return The number of bytes written on success, or a negative error code.
  /// If the number of bytes returned is less than that requested, the
  /// timeout was reached before the requested number of bytes was
  /// written. If timeout is zero, the function will always return
  /// either the requested number of bytes or a negative error code. In
  /// the event of an error there is no way to determine how many bytes
  /// were sent before the error occurred.
  ///
  /// @since 0.1.0
  int sp_blocking_write(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Void> buf,
    int count,
    int timeout_ms,
  ) {
    _sp_blocking_write ??=
        _dylib.lookupFunction<_c_sp_blocking_write, _dart_sp_blocking_write>(
            'sp_blocking_write');
    return _sp_blocking_write(
      port,
      buf,
      count,
      timeout_ms,
    );
  }

  _dart_sp_blocking_write _sp_blocking_write;

  /// Write bytes to the specified serial port, without blocking.
  ///
  /// Note that this function only ensures that the accepted bytes have been
  /// written to the OS; they may be held in driver or hardware buffers and not
  /// yet physically transmitted. To check whether all written bytes have actually
  /// been transmitted, use the sp_output_waiting() function. To wait until all
  /// written bytes have actually been transmitted, use the sp_drain() function.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] buf Buffer containing the bytes to write. Must not be NULL.
  /// @param[in] count Maximum number of bytes to write.
  ///
  /// @return The number of bytes written on success, or a negative error code.
  /// The number of bytes returned may be any number from zero to the
  /// maximum that was requested.
  ///
  /// @since 0.1.0
  int sp_nonblocking_write(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Void> buf,
    int count,
  ) {
    _sp_nonblocking_write ??= _dylib.lookupFunction<_c_sp_nonblocking_write,
        _dart_sp_nonblocking_write>('sp_nonblocking_write');
    return _sp_nonblocking_write(
      port,
      buf,
      count,
    );
  }

  _dart_sp_nonblocking_write _sp_nonblocking_write;

  /// Gets the number of bytes waiting in the input buffer.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return Number of bytes waiting on success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_input_waiting(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_input_waiting ??=
        _dylib.lookupFunction<_c_sp_input_waiting, _dart_sp_input_waiting>(
            'sp_input_waiting');
    return _sp_input_waiting(
      port,
    );
  }

  _dart_sp_input_waiting _sp_input_waiting;

  /// Gets the number of bytes waiting in the output buffer.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return Number of bytes waiting on success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_output_waiting(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_output_waiting ??=
        _dylib.lookupFunction<_c_sp_output_waiting, _dart_sp_output_waiting>(
            'sp_output_waiting');
    return _sp_output_waiting(
      port,
    );
  }

  _dart_sp_output_waiting _sp_output_waiting;

  /// Flush serial port buffers. Data in the selected buffer(s) is discarded.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] buffers Which buffer(s) to flush.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_flush(
    ffi.Pointer<sp_port> port,
    int buffers,
  ) {
    _sp_flush ??=
        _dylib.lookupFunction<_c_sp_flush, _dart_sp_flush>('sp_flush');
    return _sp_flush(
      port,
      buffers,
    );
  }

  _dart_sp_flush _sp_flush;

  /// Wait for buffered data to be transmitted.
  ///
  /// @warning If your program runs on Unix, defines its own signal handlers, and
  /// needs to abort draining the output buffer when when these are
  /// called, then you should not use this function. It repeats system
  /// calls that return with EINTR. To be able to abort a drain from a
  /// signal handler, you would need to implement your own blocking
  /// drain by polling the result of sp_output_waiting().
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_drain(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_drain ??=
        _dylib.lookupFunction<_c_sp_drain, _dart_sp_drain>('sp_drain');
    return _sp_drain(
      port,
    );
  }

  _dart_sp_drain _sp_drain;

  /// Allocate storage for a set of events.
  ///
  /// The user should allocate a variable of type struct sp_event_set *,
  /// then pass a pointer to this variable to receive the result.
  ///
  /// The result should be freed after use by calling sp_free_event_set().
  ///
  /// @param[out] result_ptr If any error is returned, the variable pointed to by
  /// result_ptr will be set to NULL. Otherwise, it will
  /// be set to point to the event set. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_new_event_set(
    ffi.Pointer<ffi.Pointer<sp_event_set>> result_ptr,
  ) {
    _sp_new_event_set ??=
        _dylib.lookupFunction<_c_sp_new_event_set, _dart_sp_new_event_set>(
            'sp_new_event_set');
    return _sp_new_event_set(
      result_ptr,
    );
  }

  _dart_sp_new_event_set _sp_new_event_set;

  /// Add events to a struct sp_event_set for a given port.
  ///
  /// The port must first be opened by calling sp_open() using the same port
  /// structure.
  ///
  /// After the port is closed or the port structure freed, the results may
  /// no longer be valid.
  ///
  /// @param[in,out] event_set Event set to update. Must not be NULL.
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[in] mask Bitmask of events to be waited for.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_add_port_events(
    ffi.Pointer<sp_event_set> event_set,
    ffi.Pointer<sp_port> port,
    int mask,
  ) {
    _sp_add_port_events ??=
        _dylib.lookupFunction<_c_sp_add_port_events, _dart_sp_add_port_events>(
            'sp_add_port_events');
    return _sp_add_port_events(
      event_set,
      port,
      mask,
    );
  }

  _dart_sp_add_port_events _sp_add_port_events;

  /// Wait for any of a set of events to occur.
  ///
  /// @param[in] event_set Event set to wait on. Must not be NULL.
  /// @param[in] timeout_ms Timeout in milliseconds, or zero to wait indefinitely.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_wait(
    ffi.Pointer<sp_event_set> event_set,
    int timeout_ms,
  ) {
    _sp_wait ??= _dylib.lookupFunction<_c_sp_wait, _dart_sp_wait>('sp_wait');
    return _sp_wait(
      event_set,
      timeout_ms,
    );
  }

  _dart_sp_wait _sp_wait;

  /// Free a structure allocated by sp_new_event_set().
  ///
  /// @param[in] event_set Event set to free. Must not be NULL.
  ///
  /// @since 0.1.0
  void sp_free_event_set(
    ffi.Pointer<sp_event_set> event_set,
  ) {
    _sp_free_event_set ??=
        _dylib.lookupFunction<_c_sp_free_event_set, _dart_sp_free_event_set>(
            'sp_free_event_set');
    return _sp_free_event_set(
      event_set,
    );
  }

  _dart_sp_free_event_set _sp_free_event_set;

  /// Gets the status of the control signals for the specified port.
  ///
  /// The user should allocate a variable of type "enum sp_signal" and pass a
  /// pointer to this variable to receive the result. The result is a bitmask
  /// in which individual signals can be checked by bitwise OR with values of
  /// the sp_signal enum.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  /// @param[out] signal_mask Pointer to a variable to receive the result.
  /// Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_get_signals(
    ffi.Pointer<sp_port> port,
    ffi.Pointer<ffi.Int32> signal_mask,
  ) {
    _sp_get_signals ??=
        _dylib.lookupFunction<_c_sp_get_signals, _dart_sp_get_signals>(
            'sp_get_signals');
    return _sp_get_signals(
      port,
      signal_mask,
    );
  }

  _dart_sp_get_signals _sp_get_signals;

  /// Put the port transmit line into the break state.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_start_break(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_start_break ??=
        _dylib.lookupFunction<_c_sp_start_break, _dart_sp_start_break>(
            'sp_start_break');
    return _sp_start_break(
      port,
    );
  }

  _dart_sp_start_break _sp_start_break;

  /// Take the port transmit line out of the break state.
  ///
  /// @param[in] port Pointer to a port structure. Must not be NULL.
  ///
  /// @return SP_OK upon success, a negative error code otherwise.
  ///
  /// @since 0.1.0
  int sp_end_break(
    ffi.Pointer<sp_port> port,
  ) {
    _sp_end_break ??= _dylib
        .lookupFunction<_c_sp_end_break, _dart_sp_end_break>('sp_end_break');
    return _sp_end_break(
      port,
    );
  }

  _dart_sp_end_break _sp_end_break;

  /// Get the error code for a failed operation.
  ///
  /// In order to obtain the correct result, this function should be called
  /// straight after the failure, before executing any other system operations.
  /// The result is thread-specific, and only valid when called immediately
  /// after a previous call returning SP_ERR_FAIL.
  ///
  /// @return The system's numeric code for the error that caused the last
  /// operation to fail.
  ///
  /// @since 0.1.0
  int sp_last_error_code() {
    _sp_last_error_code ??=
        _dylib.lookupFunction<_c_sp_last_error_code, _dart_sp_last_error_code>(
            'sp_last_error_code');
    return _sp_last_error_code();
  }

  _dart_sp_last_error_code _sp_last_error_code;

  /// Get the error message for a failed operation.
  ///
  /// In order to obtain the correct result, this function should be called
  /// straight after the failure, before executing other system operations.
  /// The result is thread-specific, and only valid when called immediately
  /// after a previous call returning SP_ERR_FAIL.
  ///
  /// @return The system's message for the error that caused the last
  /// operation to fail. This string may be allocated by the function,
  /// and should be freed after use by calling sp_free_error_message().
  ///
  /// @since 0.1.0
  ffi.Pointer<ffi.Int8> sp_last_error_message() {
    _sp_last_error_message ??= _dylib.lookupFunction<_c_sp_last_error_message,
        _dart_sp_last_error_message>('sp_last_error_message');
    return _sp_last_error_message();
  }

  _dart_sp_last_error_message _sp_last_error_message;

  /// Free an error message returned by sp_last_error_message().
  ///
  /// @param[in] message The error message string to free. Must not be NULL.
  ///
  /// @since 0.1.0
  void sp_free_error_message(
    ffi.Pointer<ffi.Int8> message,
  ) {
    _sp_free_error_message ??= _dylib.lookupFunction<_c_sp_free_error_message,
        _dart_sp_free_error_message>('sp_free_error_message');
    return _sp_free_error_message(
      message,
    );
  }

  _dart_sp_free_error_message _sp_free_error_message;

  /// Set the handler function for library debugging messages.
  ///
  /// Debugging messages are generated by the library during each operation,
  /// to help in diagnosing problems. The handler will be called for each
  /// message. The handler can be set to NULL to ignore all debug messages.
  ///
  /// The handler function should accept a format string and variable length
  /// argument list, in the same manner as e.g. printf().
  ///
  /// The default handler is sp_default_debug_handler().
  ///
  /// @param[in] handler The handler function to use. Can be NULL (in that case
  /// all debug messages will be ignored).
  ///
  /// @since 0.1.0
  void sp_set_debug_handler(
    ffi.Pointer<ffi.NativeFunction<_typedefC_1>> handler,
  ) {
    _sp_set_debug_handler ??= _dylib.lookupFunction<_c_sp_set_debug_handler,
        _dart_sp_set_debug_handler>('sp_set_debug_handler');
    return _sp_set_debug_handler(
      handler,
    );
  }

  _dart_sp_set_debug_handler _sp_set_debug_handler;

  /// Default handler function for library debugging messages.
  ///
  /// This function prints debug messages to the standard error stream if the
  /// environment variable LIBSERIALPORT_DEBUG is set. Otherwise, they are
  /// ignored.
  ///
  /// @param[in] format The format string to use. Must not be NULL.
  /// @param[in] ... The variable length argument list to use.
  ///
  /// @since 0.1.0
  void sp_default_debug_handler(
    ffi.Pointer<ffi.Int8> format,
  ) {
    _sp_default_debug_handler ??= _dylib.lookupFunction<
        _c_sp_default_debug_handler,
        _dart_sp_default_debug_handler>('sp_default_debug_handler');
    return _sp_default_debug_handler(
      format,
    );
  }

  _dart_sp_default_debug_handler _sp_default_debug_handler;

  /// Get the major libserialport package version number.
  ///
  /// @return The major package version number.
  ///
  /// @since 0.1.0
  int sp_get_major_package_version() {
    _sp_get_major_package_version ??= _dylib.lookupFunction<
        _c_sp_get_major_package_version,
        _dart_sp_get_major_package_version>('sp_get_major_package_version');
    return _sp_get_major_package_version();
  }

  _dart_sp_get_major_package_version _sp_get_major_package_version;

  /// Get the minor libserialport package version number.
  ///
  /// @return The minor package version number.
  ///
  /// @since 0.1.0
  int sp_get_minor_package_version() {
    _sp_get_minor_package_version ??= _dylib.lookupFunction<
        _c_sp_get_minor_package_version,
        _dart_sp_get_minor_package_version>('sp_get_minor_package_version');
    return _sp_get_minor_package_version();
  }

  _dart_sp_get_minor_package_version _sp_get_minor_package_version;

  /// Get the micro libserialport package version number.
  ///
  /// @return The micro package version number.
  ///
  /// @since 0.1.0
  int sp_get_micro_package_version() {
    _sp_get_micro_package_version ??= _dylib.lookupFunction<
        _c_sp_get_micro_package_version,
        _dart_sp_get_micro_package_version>('sp_get_micro_package_version');
    return _sp_get_micro_package_version();
  }

  _dart_sp_get_micro_package_version _sp_get_micro_package_version;

  /// Get the libserialport package version number as a string.
  ///
  /// @return The package version number string. The returned string is
  /// static and thus should NOT be free'd by the caller.
  ///
  /// @since 0.1.0
  ffi.Pointer<ffi.Int8> sp_get_package_version_string() {
    _sp_get_package_version_string ??= _dylib.lookupFunction<
        _c_sp_get_package_version_string,
        _dart_sp_get_package_version_string>('sp_get_package_version_string');
    return _sp_get_package_version_string();
  }

  _dart_sp_get_package_version_string _sp_get_package_version_string;

  /// Get the "current" part of the libserialport library version number.
  ///
  /// @return The "current" library version number.
  ///
  /// @since 0.1.0
  int sp_get_current_lib_version() {
    _sp_get_current_lib_version ??= _dylib.lookupFunction<
        _c_sp_get_current_lib_version,
        _dart_sp_get_current_lib_version>('sp_get_current_lib_version');
    return _sp_get_current_lib_version();
  }

  _dart_sp_get_current_lib_version _sp_get_current_lib_version;

  /// Get the "revision" part of the libserialport library version number.
  ///
  /// @return The "revision" library version number.
  ///
  /// @since 0.1.0
  int sp_get_revision_lib_version() {
    _sp_get_revision_lib_version ??= _dylib.lookupFunction<
        _c_sp_get_revision_lib_version,
        _dart_sp_get_revision_lib_version>('sp_get_revision_lib_version');
    return _sp_get_revision_lib_version();
  }

  _dart_sp_get_revision_lib_version _sp_get_revision_lib_version;

  /// Get the "age" part of the libserialport library version number.
  ///
  /// @return The "age" library version number.
  ///
  /// @since 0.1.0
  int sp_get_age_lib_version() {
    _sp_get_age_lib_version ??= _dylib.lookupFunction<_c_sp_get_age_lib_version,
        _dart_sp_get_age_lib_version>('sp_get_age_lib_version');
    return _sp_get_age_lib_version();
  }

  _dart_sp_get_age_lib_version _sp_get_age_lib_version;

  /// Get the libserialport library version number as a string.
  ///
  /// @return The library version number string. The returned string is
  /// static and thus should NOT be free'd by the caller.
  ///
  /// @since 0.1.0
  ffi.Pointer<ffi.Int8> sp_get_lib_version_string() {
    _sp_get_lib_version_string ??= _dylib.lookupFunction<
        _c_sp_get_lib_version_string,
        _dart_sp_get_lib_version_string>('sp_get_lib_version_string');
    return _sp_get_lib_version_string();
  }

  _dart_sp_get_lib_version_string _sp_get_lib_version_string;
}

/// Return values.
abstract class sp_return {
  /// Operation completed successfully.
  static const int SP_OK = 0;

  /// Invalid arguments were passed to the function.
  static const int SP_ERR_ARG = -1;

  /// A system error occurred while executing the operation.
  static const int SP_ERR_FAIL = -2;

  /// A memory allocation failed while executing the operation.
  static const int SP_ERR_MEM = -3;

  /// The requested operation is not supported by this system or device.
  static const int SP_ERR_SUPP = -4;
}

/// Port access modes.
abstract class sp_mode {
  /// Open port for read access.
  static const int SP_MODE_READ = 1;

  /// Open port for write access.
  static const int SP_MODE_WRITE = 2;

  /// Open port for read and write access. @since 0.1.1
  static const int SP_MODE_READ_WRITE = 3;
}

/// Port events.
abstract class sp_event {
  /// Data received and ready to read.
  static const int SP_EVENT_RX_READY = 1;

  /// Ready to transmit new data.
  static const int SP_EVENT_TX_READY = 2;

  /// Error occurred.
  static const int SP_EVENT_ERROR = 4;
}

/// Buffer selection.
abstract class sp_buffer {
  /// Input buffer.
  static const int SP_BUF_INPUT = 1;

  /// Output buffer.
  static const int SP_BUF_OUTPUT = 2;

  /// Both buffers.
  static const int SP_BUF_BOTH = 3;
}

/// Parity settings.
abstract class sp_parity {
  /// Special value to indicate setting should be left alone.
  static const int SP_PARITY_INVALID = -1;

  /// No parity.
  static const int SP_PARITY_NONE = 0;

  /// Odd parity.
  static const int SP_PARITY_ODD = 1;

  /// Even parity.
  static const int SP_PARITY_EVEN = 2;

  /// Mark parity.
  static const int SP_PARITY_MARK = 3;

  /// Space parity.
  static const int SP_PARITY_SPACE = 4;
}

/// RTS pin behaviour.
abstract class sp_rts {
  /// Special value to indicate setting should be left alone.
  static const int SP_RTS_INVALID = -1;

  /// RTS off.
  static const int SP_RTS_OFF = 0;

  /// RTS on.
  static const int SP_RTS_ON = 1;

  /// RTS used for flow control.
  static const int SP_RTS_FLOW_CONTROL = 2;
}

/// CTS pin behaviour.
abstract class sp_cts {
  /// Special value to indicate setting should be left alone.
  static const int SP_CTS_INVALID = -1;

  /// CTS ignored.
  static const int SP_CTS_IGNORE = 0;

  /// CTS used for flow control.
  static const int SP_CTS_FLOW_CONTROL = 1;
}

/// DTR pin behaviour.
abstract class sp_dtr {
  /// Special value to indicate setting should be left alone.
  static const int SP_DTR_INVALID = -1;

  /// DTR off.
  static const int SP_DTR_OFF = 0;

  /// DTR on.
  static const int SP_DTR_ON = 1;

  /// DTR used for flow control.
  static const int SP_DTR_FLOW_CONTROL = 2;
}

/// DSR pin behaviour.
abstract class sp_dsr {
  /// Special value to indicate setting should be left alone.
  static const int SP_DSR_INVALID = -1;

  /// DSR ignored.
  static const int SP_DSR_IGNORE = 0;

  /// DSR used for flow control.
  static const int SP_DSR_FLOW_CONTROL = 1;
}

/// XON/XOFF flow control behaviour.
abstract class sp_xonxoff {
  /// Special value to indicate setting should be left alone.
  static const int SP_XONXOFF_INVALID = -1;

  /// XON/XOFF disabled.
  static const int SP_XONXOFF_DISABLED = 0;

  /// XON/XOFF enabled for input only.
  static const int SP_XONXOFF_IN = 1;

  /// XON/XOFF enabled for output only.
  static const int SP_XONXOFF_OUT = 2;

  /// XON/XOFF enabled for input and output.
  static const int SP_XONXOFF_INOUT = 3;
}

/// Standard flow control combinations.
abstract class sp_flowcontrol {
  /// No flow control.
  static const int SP_FLOWCONTROL_NONE = 0;

  /// Software flow control using XON/XOFF characters.
  static const int SP_FLOWCONTROL_XONXOFF = 1;

  /// Hardware flow control using RTS/CTS signals.
  static const int SP_FLOWCONTROL_RTSCTS = 2;

  /// Hardware flow control using DTR/DSR signals.
  static const int SP_FLOWCONTROL_DTRDSR = 3;
}

/// Input signals.
abstract class sp_signal {
  /// Clear to send.
  static const int SP_SIG_CTS = 1;

  /// Data set ready.
  static const int SP_SIG_DSR = 2;

  /// Data carrier detect.
  static const int SP_SIG_DCD = 4;

  /// Ring indicator.
  static const int SP_SIG_RI = 8;
}

/// Transport types.
///
/// @since 0.1.1
abstract class sp_transport {
  /// Native platform serial port. @since 0.1.1
  static const int SP_TRANSPORT_NATIVE = 0;

  /// USB serial port adapter. @since 0.1.1
  static const int SP_TRANSPORT_USB = 1;

  /// Bluetooth serial port adapter. @since 0.1.1
  static const int SP_TRANSPORT_BLUETOOTH = 2;

  /// Pseudo serial port. @since 0.1.2
  static const int SP_TRANSPORT_PSEUDO = 3;
}

/// @struct sp_port
/// An opaque structure representing a serial port.
class sp_port extends ffi.Struct {}

/// @struct sp_port_config
/// An opaque structure representing the configuration for a serial port.
class sp_port_config extends ffi.Struct {}

/// @struct sp_event_set
/// A set of handles to wait on for events.
class sp_event_set extends ffi.Struct {
  /// Array of OS-specific handles.
  ffi.Pointer<ffi.Void> handles;

  /// Array of bitmasks indicating which events apply for each handle.
  ffi.Pointer<ffi.Int32> masks;

  /// Number of handles.
  @ffi.Uint32()
  int count;
}

const int SP_PACKAGE_VERSION_MAJOR = 0;

const int SP_PACKAGE_VERSION_MINOR = 1;

const int SP_PACKAGE_VERSION_MICRO = 1;

const String SP_PACKAGE_VERSION_STRING = '0.1.1';

const int SP_LIB_VERSION_CURRENT = 1;

const int SP_LIB_VERSION_REVISION = 0;

const int SP_LIB_VERSION_AGE = 1;

const String SP_LIB_VERSION_STRING = '1:0:1';

typedef _c_sp_get_port_by_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> portname,
  ffi.Pointer<ffi.Pointer<sp_port>> port_ptr,
);

typedef _dart_sp_get_port_by_name = int Function(
  ffi.Pointer<ffi.Int8> portname,
  ffi.Pointer<ffi.Pointer<sp_port>> port_ptr,
);

typedef _c_sp_free_port = ffi.Void Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_free_port = void Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_list_ports = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Pointer<sp_port>>> list_ptr,
);

typedef _dart_sp_list_ports = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Pointer<sp_port>>> list_ptr,
);

typedef _c_sp_copy_port = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Pointer<sp_port>> copy_ptr,
);

typedef _dart_sp_copy_port = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Pointer<sp_port>> copy_ptr,
);

typedef _c_sp_free_port_list = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<sp_port>> ports,
);

typedef _dart_sp_free_port_list = void Function(
  ffi.Pointer<ffi.Pointer<sp_port>> ports,
);

typedef _c_sp_open = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 flags,
);

typedef _dart_sp_open = int Function(
  ffi.Pointer<sp_port> port,
  int flags,
);

typedef _c_sp_close = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_close = int Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_get_port_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_get_port_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_get_port_description = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_get_port_description = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_get_port_transport = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_get_port_transport = int Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_get_port_usb_bus_address = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Int32> usb_bus,
  ffi.Pointer<ffi.Int32> usb_address,
);

typedef _dart_sp_get_port_usb_bus_address = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Int32> usb_bus,
  ffi.Pointer<ffi.Int32> usb_address,
);

typedef _c_sp_get_port_usb_vid_pid = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Int32> usb_vid,
  ffi.Pointer<ffi.Int32> usb_pid,
);

typedef _dart_sp_get_port_usb_vid_pid = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Int32> usb_vid,
  ffi.Pointer<ffi.Int32> usb_pid,
);

typedef _c_sp_get_port_usb_manufacturer = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_get_port_usb_manufacturer = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_get_port_usb_product = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_get_port_usb_product = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_get_port_usb_serial = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_get_port_usb_serial = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_get_port_bluetooth_address = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_get_port_bluetooth_address = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_get_port_handle = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> result_ptr,
);

typedef _dart_sp_get_port_handle = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> result_ptr,
);

typedef _c_sp_new_config = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<sp_port_config>> config_ptr,
);

typedef _dart_sp_new_config = int Function(
  ffi.Pointer<ffi.Pointer<sp_port_config>> config_ptr,
);

typedef _c_sp_free_config = ffi.Void Function(
  ffi.Pointer<sp_port_config> config,
);

typedef _dart_sp_free_config = void Function(
  ffi.Pointer<sp_port_config> config,
);

typedef _c_sp_get_config = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<sp_port_config> config,
);

typedef _dart_sp_get_config = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<sp_port_config> config,
);

typedef _c_sp_set_config = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<sp_port_config> config,
);

typedef _dart_sp_set_config = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<sp_port_config> config,
);

typedef _c_sp_set_baudrate = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 baudrate,
);

typedef _dart_sp_set_baudrate = int Function(
  ffi.Pointer<sp_port> port,
  int baudrate,
);

typedef _c_sp_get_config_baudrate = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> baudrate_ptr,
);

typedef _dart_sp_get_config_baudrate = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> baudrate_ptr,
);

typedef _c_sp_set_config_baudrate = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 baudrate,
);

typedef _dart_sp_set_config_baudrate = int Function(
  ffi.Pointer<sp_port_config> config,
  int baudrate,
);

typedef _c_sp_set_bits = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 bits,
);

typedef _dart_sp_set_bits = int Function(
  ffi.Pointer<sp_port> port,
  int bits,
);

typedef _c_sp_get_config_bits = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> bits_ptr,
);

typedef _dart_sp_get_config_bits = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> bits_ptr,
);

typedef _c_sp_set_config_bits = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 bits,
);

typedef _dart_sp_set_config_bits = int Function(
  ffi.Pointer<sp_port_config> config,
  int bits,
);

typedef _c_sp_set_parity = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 parity,
);

typedef _dart_sp_set_parity = int Function(
  ffi.Pointer<sp_port> port,
  int parity,
);

typedef _c_sp_get_config_parity = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> parity_ptr,
);

typedef _dart_sp_get_config_parity = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> parity_ptr,
);

typedef _c_sp_set_config_parity = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 parity,
);

typedef _dart_sp_set_config_parity = int Function(
  ffi.Pointer<sp_port_config> config,
  int parity,
);

typedef _c_sp_set_stopbits = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 stopbits,
);

typedef _dart_sp_set_stopbits = int Function(
  ffi.Pointer<sp_port> port,
  int stopbits,
);

typedef _c_sp_get_config_stopbits = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> stopbits_ptr,
);

typedef _dart_sp_get_config_stopbits = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> stopbits_ptr,
);

typedef _c_sp_set_config_stopbits = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 stopbits,
);

typedef _dart_sp_set_config_stopbits = int Function(
  ffi.Pointer<sp_port_config> config,
  int stopbits,
);

typedef _c_sp_set_rts = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 rts,
);

typedef _dart_sp_set_rts = int Function(
  ffi.Pointer<sp_port> port,
  int rts,
);

typedef _c_sp_get_config_rts = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> rts_ptr,
);

typedef _dart_sp_get_config_rts = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> rts_ptr,
);

typedef _c_sp_set_config_rts = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 rts,
);

typedef _dart_sp_set_config_rts = int Function(
  ffi.Pointer<sp_port_config> config,
  int rts,
);

typedef _c_sp_set_cts = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 cts,
);

typedef _dart_sp_set_cts = int Function(
  ffi.Pointer<sp_port> port,
  int cts,
);

typedef _c_sp_get_config_cts = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> cts_ptr,
);

typedef _dart_sp_get_config_cts = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> cts_ptr,
);

typedef _c_sp_set_config_cts = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 cts,
);

typedef _dart_sp_set_config_cts = int Function(
  ffi.Pointer<sp_port_config> config,
  int cts,
);

typedef _c_sp_set_dtr = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 dtr,
);

typedef _dart_sp_set_dtr = int Function(
  ffi.Pointer<sp_port> port,
  int dtr,
);

typedef _c_sp_get_config_dtr = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> dtr_ptr,
);

typedef _dart_sp_get_config_dtr = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> dtr_ptr,
);

typedef _c_sp_set_config_dtr = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 dtr,
);

typedef _dart_sp_set_config_dtr = int Function(
  ffi.Pointer<sp_port_config> config,
  int dtr,
);

typedef _c_sp_set_dsr = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 dsr,
);

typedef _dart_sp_set_dsr = int Function(
  ffi.Pointer<sp_port> port,
  int dsr,
);

typedef _c_sp_get_config_dsr = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> dsr_ptr,
);

typedef _dart_sp_get_config_dsr = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> dsr_ptr,
);

typedef _c_sp_set_config_dsr = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 dsr,
);

typedef _dart_sp_set_config_dsr = int Function(
  ffi.Pointer<sp_port_config> config,
  int dsr,
);

typedef _c_sp_set_xon_xoff = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 xon_xoff,
);

typedef _dart_sp_set_xon_xoff = int Function(
  ffi.Pointer<sp_port> port,
  int xon_xoff,
);

typedef _c_sp_get_config_xon_xoff = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> xon_xoff_ptr,
);

typedef _dart_sp_get_config_xon_xoff = int Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Pointer<ffi.Int32> xon_xoff_ptr,
);

typedef _c_sp_set_config_xon_xoff = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 xon_xoff,
);

typedef _dart_sp_set_config_xon_xoff = int Function(
  ffi.Pointer<sp_port_config> config,
  int xon_xoff,
);

typedef _c_sp_set_config_flowcontrol = ffi.Int32 Function(
  ffi.Pointer<sp_port_config> config,
  ffi.Int32 flowcontrol,
);

typedef _dart_sp_set_config_flowcontrol = int Function(
  ffi.Pointer<sp_port_config> config,
  int flowcontrol,
);

typedef _c_sp_set_flowcontrol = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 flowcontrol,
);

typedef _dart_sp_set_flowcontrol = int Function(
  ffi.Pointer<sp_port> port,
  int flowcontrol,
);

typedef _c_sp_blocking_read = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  ffi.Uint64 count,
  ffi.Uint32 timeout_ms,
);

typedef _dart_sp_blocking_read = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  int count,
  int timeout_ms,
);

typedef _c_sp_blocking_read_next = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  ffi.Uint64 count,
  ffi.Uint32 timeout_ms,
);

typedef _dart_sp_blocking_read_next = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  int count,
  int timeout_ms,
);

typedef _c_sp_nonblocking_read = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  ffi.Uint64 count,
);

typedef _dart_sp_nonblocking_read = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  int count,
);

typedef _c_sp_blocking_write = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  ffi.Uint64 count,
  ffi.Uint32 timeout_ms,
);

typedef _dart_sp_blocking_write = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  int count,
  int timeout_ms,
);

typedef _c_sp_nonblocking_write = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  ffi.Uint64 count,
);

typedef _dart_sp_nonblocking_write = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Void> buf,
  int count,
);

typedef _c_sp_input_waiting = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_input_waiting = int Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_output_waiting = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_output_waiting = int Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_flush = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Int32 buffers,
);

typedef _dart_sp_flush = int Function(
  ffi.Pointer<sp_port> port,
  int buffers,
);

typedef _c_sp_drain = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_drain = int Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_new_event_set = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<sp_event_set>> result_ptr,
);

typedef _dart_sp_new_event_set = int Function(
  ffi.Pointer<ffi.Pointer<sp_event_set>> result_ptr,
);

typedef _c_sp_add_port_events = ffi.Int32 Function(
  ffi.Pointer<sp_event_set> event_set,
  ffi.Pointer<sp_port> port,
  ffi.Int32 mask,
);

typedef _dart_sp_add_port_events = int Function(
  ffi.Pointer<sp_event_set> event_set,
  ffi.Pointer<sp_port> port,
  int mask,
);

typedef _c_sp_wait = ffi.Int32 Function(
  ffi.Pointer<sp_event_set> event_set,
  ffi.Uint32 timeout_ms,
);

typedef _dart_sp_wait = int Function(
  ffi.Pointer<sp_event_set> event_set,
  int timeout_ms,
);

typedef _c_sp_free_event_set = ffi.Void Function(
  ffi.Pointer<sp_event_set> event_set,
);

typedef _dart_sp_free_event_set = void Function(
  ffi.Pointer<sp_event_set> event_set,
);

typedef _c_sp_get_signals = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Int32> signal_mask,
);

typedef _dart_sp_get_signals = int Function(
  ffi.Pointer<sp_port> port,
  ffi.Pointer<ffi.Int32> signal_mask,
);

typedef _c_sp_start_break = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_start_break = int Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_end_break = ffi.Int32 Function(
  ffi.Pointer<sp_port> port,
);

typedef _dart_sp_end_break = int Function(
  ffi.Pointer<sp_port> port,
);

typedef _c_sp_last_error_code = ffi.Int32 Function();

typedef _dart_sp_last_error_code = int Function();

typedef _c_sp_last_error_message = ffi.Pointer<ffi.Int8> Function();

typedef _dart_sp_last_error_message = ffi.Pointer<ffi.Int8> Function();

typedef _c_sp_free_error_message = ffi.Void Function(
  ffi.Pointer<ffi.Int8> message,
);

typedef _dart_sp_free_error_message = void Function(
  ffi.Pointer<ffi.Int8> message,
);

typedef _typedefC_1 = ffi.Void Function(
  ffi.Pointer<ffi.Int8>,
);

typedef _c_sp_set_debug_handler = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> handler,
);

typedef _dart_sp_set_debug_handler = void Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> handler,
);

typedef _c_sp_default_debug_handler = ffi.Void Function(
  ffi.Pointer<ffi.Int8> format,
);

typedef _dart_sp_default_debug_handler = void Function(
  ffi.Pointer<ffi.Int8> format,
);

typedef _c_sp_get_major_package_version = ffi.Int32 Function();

typedef _dart_sp_get_major_package_version = int Function();

typedef _c_sp_get_minor_package_version = ffi.Int32 Function();

typedef _dart_sp_get_minor_package_version = int Function();

typedef _c_sp_get_micro_package_version = ffi.Int32 Function();

typedef _dart_sp_get_micro_package_version = int Function();

typedef _c_sp_get_package_version_string = ffi.Pointer<ffi.Int8> Function();

typedef _dart_sp_get_package_version_string = ffi.Pointer<ffi.Int8> Function();

typedef _c_sp_get_current_lib_version = ffi.Int32 Function();

typedef _dart_sp_get_current_lib_version = int Function();

typedef _c_sp_get_revision_lib_version = ffi.Int32 Function();

typedef _dart_sp_get_revision_lib_version = int Function();

typedef _c_sp_get_age_lib_version = ffi.Int32 Function();

typedef _dart_sp_get_age_lib_version = int Function();

typedef _c_sp_get_lib_version_string = ffi.Pointer<ffi.Int8> Function();

typedef _dart_sp_get_lib_version_string = ffi.Pointer<ffi.Int8> Function();
